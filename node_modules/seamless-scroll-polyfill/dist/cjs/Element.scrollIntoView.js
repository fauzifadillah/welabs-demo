"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementScrollIntoViewPolyfill = exports.elementScrollIntoView = void 0;
const common_js_1 = require("./common.js");
const Element_scroll_js_1 = require("./Element.scroll.js");
// https://drafts.csswg.org/css-writing-modes-4/#block-flow
const normalizeWritingMode = (writingMode) => {
    switch (writingMode) {
        case "horizontal-tb":
        case "lr":
        case "lr-tb":
        case "rl":
        case "rl-tb":
            return 0 /* HorizontalTb */;
        case "vertical-rl":
        case "tb":
        case "tb-rl":
            return 1 /* VerticalRl */;
        case "vertical-lr":
        case "tb-lr":
            return 2 /* VerticalLr */;
        case "sideways-rl":
            return 3 /* SidewaysRl */;
        case "sideways-lr":
            return 4 /* SidewaysLr */;
    }
    return 0 /* HorizontalTb */;
};
// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0
const toPhysicalAlignment = (options, writingMode, isLTR) => {
    let [xPos, yPos] = [options.block || "start", options.inline || "nearest"];
    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */
    let layout = 0b00;
    /**
     * WritingMode.VerticalLr: ↓→
     * | 1 | 4 |   |
     * | 2 | 5 |   |
     * | 3 |   |   |
     *
     * RTL: ↑→
     * | 3 |   |   |
     * | 2 | 5 |   |
     * | 1 | 4 |   |
     */
    if (!isLTR) {
        layout ^= 2 /* ReverseVertical */;
    }
    switch (writingMode) {
        /**
         * ↓→
         * | 1 | 2 | 3 |
         * | 4 | 5 |   |
         * |   |   |   |
         *
         * RTL: ↓←
         * | 3 | 2 | 1 |
         * |   | 5 | 4 |
         * |   |   |   |
         */
        case 0 /* HorizontalTb */:
            // swap horizontal and vertical
            layout = (layout >> 1) | ((layout & 1) << 1);
            [xPos, yPos] = [yPos, xPos];
            break;
        /**
         * ↓←
         * |   | 4 | 1 |
         * |   | 5 | 2 |
         * |   |   | 3 |
         *
         * RTL: ↑←
         * |   |   | 3 |
         * |   | 5 | 2 |
         * |   | 4 | 1 |
         */
        case 1 /* VerticalRl */:
        case 3 /* SidewaysRl */:
            //  reverse horizontal
            layout ^= 1 /* ReverseHorizontal */;
            break;
        /**
         * ↑→
         * | 3 |   |   |
         * | 2 | 5 |   |
         * | 1 | 4 |   |
         *
         * RTL: ↓→
         * | 1 | 4 |   |
         * | 2 | 5 |   |
         * | 3 |   |   |
         */
        case 4 /* SidewaysLr */:
            // reverse vertical
            layout ^= 2 /* ReverseVertical */;
            break;
    }
    return [xPos, yPos].map((value, index) => {
        switch (value) {
            case "center":
                return 1 /* CenterAlways */;
            case "nearest":
                return 0 /* ToEdgeIfNeeded */;
            default: {
                const reverse = (layout >> index) & 1;
                return (value === "start") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;
            }
        }
    });
};
// code from stipsan/compute-scroll-into-view
// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts
/**
 * Find out which edge to align against when logical scroll position is "nearest"
 * Interesting fact: "nearest" works similarily to "if-needed", if the element is fully visible it will not scroll it
 *
 * Legends:
 * ┌────────┐ ┏ ━ ━ ━ ┓
 * │ target │   frame
 * └────────┘ ┗ ━ ━ ━ ┛
 */
const alignNearest = (scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) => {
    /**
     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
     *
     *          ┌──┐
     *        ┏━│━━│━┓
     *          │  │
     *        ┃ │  │ ┃        do nothing
     *          │  │
     *        ┗━│━━│━┛
     *          └──┘
     *
     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
     *
     *    ┏ ━ ━ ━ ━ ┓
     *   ┌───────────┐
     *   │┃         ┃│        do nothing
     *   └───────────┘
     *    ┗ ━ ━ ━ ━ ┛
     */
    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||
        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {
        return 0;
    }
    /**
     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height
     *
     *          ┌──┐
     *        ┏━│━━│━┓         ┏━┌━━┐━┓
     *          └──┘             │  │
     *  from  ┃      ┃     to  ┃ └──┘ ┃
     *
     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛
     *
     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
     *
     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓
     *                           │  │
     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃
     *          │  │             │  │
     *        ┗━│━━│━┛         ┗━│━━│━┛
     *          │  │             └──┘
     *          │  │
     *          └──┘
     *
     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width
     *
     *       from                 to
     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
     *  ┌───┐                 ┌───┐
     *  │ ┃ │       ┃         ┃   │     ┃
     *  └───┘                 └───┘
     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
     *
     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
     *
     *       from                 to
     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
     *        ┌───────────┐   ┌───────────┐
     *    ┃   │     ┃     │   ┃         ┃ │
     *        └───────────┘   └───────────┘
     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
     */
    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||
        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {
        return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
    }
    /**
     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height
     *
     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓
     *
     *  from  ┃      ┃     to  ┃ ┌──┐ ┃
     *          ┌──┐             │  │
     *        ┗━│━━│━┛         ┗━└━━┘━┛
     *          └──┘
     *
     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
     *
     *          ┌──┐
     *          │  │
     *          │  │             ┌──┐
     *        ┏━│━━│━┓         ┏━│━━│━┓
     *          │  │             │  │
     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃
     *                           │  │
     *        ┗━ ━━ ━┛         ┗━└━━┘━┛
     *
     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
     *
     *           from                 to
     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
     *  ┌───────────┐           ┌───────────┐
     *  │     ┃     │   ┃       │ ┃         ┃
     *  └───────────┘           └───────────┘
     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
     *
     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width
     *
     *           from                 to
     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
     *                ┌───┐             ┌───┐
     *        ┃       │ ┃ │       ┃     │   ┃
     *                └───┘             └───┘
     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
     *
     */
    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||
        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {
        return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
    }
    return 0;
};
const canOverflow = (overflow) => {
    return overflow !== "visible" && overflow !== "clip";
};
const getFrameElement = (element) => {
    if (!element.ownerDocument || !element.ownerDocument.defaultView) {
        return null;
    }
    try {
        return element.ownerDocument.defaultView.frameElement;
    }
    catch (e) {
        return null;
    }
};
const isHiddenByFrame = (element) => {
    const frame = getFrameElement(element);
    if (!frame) {
        return false;
    }
    return frame.clientHeight < element.scrollHeight || frame.clientWidth < element.scrollWidth;
};
const isScrollable = (element, computedStyle) => {
    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {
        return canOverflow(computedStyle.overflowY) || canOverflow(computedStyle.overflowX) || isHiddenByFrame(element);
    }
    return false;
};
const parentElement = (element) => {
    const parentNode = element.parentNode;
    if (parentNode !== null && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        return parentNode.host;
    }
    return parentNode;
};
const clamp = (value, width) => {
    if (value < -width) {
        return -width;
    }
    if (value > width) {
        return width;
    }
    return value;
};
const isCSSPropertySupported = (property) => property in document.documentElement.style;
const getSupportedScrollMarginProperty = () => {
    // Webkit uses "scroll-snap-margin" https://bugs.webkit.org/show_bug.cgi?id=189265.
    return ["scroll-margin", "scroll-snap-margin"].filter(isCSSPropertySupported)[0];
};
const getElementScrollSnapArea = (element, computedStyle) => {
    const { top, right, bottom, left } = element.getBoundingClientRect();
    const [scrollMarginTop, scrollMarginRight, scrollMarginBottom, scrollMarginLeft] = [
        "top",
        "right",
        "bottom",
        "left",
    ].map((edge) => {
        const scrollProperty = getSupportedScrollMarginProperty();
        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);
        return parseInt(value, 10) || 0;
    });
    return [top - scrollMarginTop, right + scrollMarginRight, bottom + scrollMarginBottom, left - scrollMarginLeft];
};
exports.elementScrollIntoView = (element, options) => {
    if (element.isConnected === false) {
        return;
    }
    // On Chrome and Firefox, document.scrollingElement will return the <html> element.
    // Safari, document.scrollingElement will return the <body> element.
    // On Edge, document.scrollingElement will return the <body> element.
    // IE11 does not support document.scrollingElement, but you can assume its <html>.
    // Used to handle the top most element that can be scrolled
    const scrollingElement = document.scrollingElement || document.documentElement;
    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box
    const frames = [];
    const documentElementStyle = getComputedStyle(document.documentElement);
    for (let cursor = parentElement(element); cursor !== null; cursor = parentElement(cursor)) {
        // Stop when we reach the viewport
        if (cursor === scrollingElement) {
            frames.push(cursor);
            break;
        }
        const cursorStyle = getComputedStyle(cursor);
        // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable
        if (cursor === document.body &&
            isScrollable(cursor, cursorStyle) &&
            !isScrollable(document.documentElement, documentElementStyle)) {
            continue;
        }
        // Now we check if the element is scrollable,
        // this code only runs if the loop haven't already hit the viewport or a custom boundary
        if (isScrollable(cursor, cursorStyle)) {
            frames.push(cursor);
        }
        if (cursorStyle.position === "fixed") {
            break;
        }
    }
    // Support pinch-zooming properly, making sure elements scroll into the visual viewport
    // Browsers that don't support visualViewport
    // will report the layout viewport dimensions on document.documentElement.clientWidth/Height
    // and viewport dimensions on window.innerWidth/Height
    // https://www.quirksmode.org/mobile/viewports2.html
    // https://bokand.github.io/viewport/index.html
    const viewportWidth = window.visualViewport ? window.visualViewport.width : innerWidth;
    const viewportHeight = window.visualViewport ? window.visualViewport.height : innerHeight;
    // Newer browsers supports scroll[X|Y], page[X|Y]Offset is
    const viewportX = window.scrollX || window.pageXOffset;
    const viewportY = window.scrollY || window.pageYOffset;
    const computedStyle = getComputedStyle(element);
    const [targetTop, targetRight, targetBottom, targetLeft] = getElementScrollSnapArea(element, computedStyle);
    const targetHeight = targetBottom - targetTop;
    const targetWidth = targetRight - targetLeft;
    const writingMode = normalizeWritingMode(computedStyle.writingMode ||
        computedStyle.getPropertyValue("-webkit-writing-mode") ||
        computedStyle.getPropertyValue("-ms-writing-mode"));
    const isLTR = computedStyle.direction !== "rtl";
    const [alignX, alignY] = toPhysicalAlignment(options, writingMode, isLTR);
    let targetBlock = (() => {
        switch (alignY) {
            case 1 /* CenterAlways */:
                return targetTop + targetHeight / 2;
            case 2 /* LeftOrTop */:
            case 0 /* ToEdgeIfNeeded */:
                return targetTop;
            case 3 /* RightOrBottom */:
                return targetBottom;
        }
    })();
    let targetInline = (() => {
        switch (alignX) {
            case 1 /* CenterAlways */:
                return targetLeft + targetWidth / 2;
            case 3 /* RightOrBottom */:
                return targetRight;
            case 2 /* LeftOrTop */:
            case 0 /* ToEdgeIfNeeded */:
                return targetLeft;
        }
    })();
    const actions = [];
    frames.forEach((frame) => {
        const { height, width, top, right, bottom, left } = frame.getBoundingClientRect();
        const frameStyle = getComputedStyle(frame);
        const borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
        const borderTop = parseInt(frameStyle.borderTopWidth, 10);
        const borderRight = parseInt(frameStyle.borderRightWidth, 10);
        const borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
        let blockScroll = 0;
        let inlineScroll = 0;
        // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them,
        // but any Element might pass by here
        // @TODO find out if the "as HTMLElement" overrides can be dropped
        const scrollbarWidth = "offsetWidth" in frame
            ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight
            : 0;
        const scrollbarHeight = "offsetHeight" in frame
            ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom
            : 0;
        if (scrollingElement === frame) {
            // Handle viewport logic (document.documentElement or document.body)
            switch (alignY) {
                case 2 /* LeftOrTop */: {
                    blockScroll = targetBlock;
                    break;
                }
                case 3 /* RightOrBottom */: {
                    blockScroll = targetBlock - viewportHeight;
                    break;
                }
                case 1 /* CenterAlways */: {
                    blockScroll = targetBlock - viewportHeight / 2;
                    break;
                }
                case 0 /* ToEdgeIfNeeded */: {
                    blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
                    break;
                }
            }
            switch (alignX) {
                case 2 /* LeftOrTop */: {
                    inlineScroll = targetInline;
                    break;
                }
                case 3 /* RightOrBottom */: {
                    inlineScroll = targetInline - viewportWidth;
                    break;
                }
                case 1 /* CenterAlways */: {
                    inlineScroll = targetInline - viewportWidth / 2;
                    break;
                }
                case 0 /* ToEdgeIfNeeded */: {
                    inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
                    break;
                }
            }
            blockScroll += viewportY;
            inlineScroll += viewportX;
        }
        else {
            // Handle each scrolling frame that might exist between the target and the viewport
            switch (alignY) {
                case 2 /* LeftOrTop */: {
                    blockScroll = targetBlock - top - borderTop;
                    break;
                }
                case 3 /* RightOrBottom */: {
                    blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
                    break;
                }
                case 1 /* CenterAlways */: {
                    blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
                    break;
                }
                case 0 /* ToEdgeIfNeeded */: {
                    blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
                    break;
                }
            }
            switch (alignX) {
                case 2 /* LeftOrTop */: {
                    inlineScroll = targetInline - left - borderLeft;
                    break;
                }
                case 3 /* RightOrBottom */: {
                    inlineScroll = targetInline - right + borderRight + scrollbarWidth;
                    break;
                }
                case 1 /* CenterAlways */: {
                    inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
                    break;
                }
                case 0 /* ToEdgeIfNeeded */: {
                    inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
                    break;
                }
            }
            const { scrollLeft, scrollTop } = frame;
            // Ensure scroll coordinates are not out of bounds while applying scroll offsets
            blockScroll = clamp(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight);
            inlineScroll = clamp(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth);
            // Cache the offset so that parent frames can scroll this into view correctly
            targetBlock += scrollTop - blockScroll;
            targetInline += scrollLeft - inlineScroll;
        }
        actions.push(() => Element_scroll_js_1.elementScroll(frame, Object.assign(Object.assign({}, options), { top: blockScroll, left: inlineScroll })));
    });
    actions.forEach((run) => run());
};
exports.elementScrollIntoViewPolyfill = (animationOptions) => {
    if (common_js_1.isScrollBehaviorSupported()) {
        return;
    }
    const originalFunc = common_js_1.original.elementScrollIntoView;
    common_js_1.modifyPrototypes((prototype) => (prototype.scrollIntoView = function scrollIntoView() {
        const scrollIntoViewOptions = arguments[0];
        if (arguments.length === 1 && common_js_1.isObject(scrollIntoViewOptions)) {
            return exports.elementScrollIntoView(this, Object.assign(Object.assign({}, scrollIntoViewOptions), animationOptions));
        }
        return originalFunc.apply(this, arguments);
    }));
};
//# sourceMappingURL=Element.scrollIntoView.js.map