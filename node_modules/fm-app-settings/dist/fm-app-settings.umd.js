(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('fmv-layout')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'fmv-layout'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FmAppSettings = {}, global.Vue, global.fmvLayout));
}(this, (function (exports, Vue, fmvLayout) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);

  const NAMESPACE = 'fm-app-settings';

  const ID = () => `_${Math.random().toString(36).substr(2, 9)}`;

  class Session {
    constructor(namespace) {
      this.namespace = namespace;
    }

    defaultNamespace() {
      // session based unique namespace
      let namespace = window.localStorage.getItem(`${ NAMESPACE }.namespace`);
      if (!namespace) {
        namespace = ID();
      }
      return namespace
    }

    get namespace() {
      return this._namespace
    }

    set namespace(namespace) {
      if (!namespace) {
        namespace = this.defaultNamespace();
      }
      this._namespace = namespace;
      window.localStorage.setItem(`${ NAMESPACE }.namespace`, namespace);
    }

    getMemoryKey(key) {
      return `${ NAMESPACE }.${ this.namespace }.${key}`
    }

    save(key, value) {
      window.localStorage.setItem(this.getMemoryKey(key), JSON.stringify(value));
    }

    memory(key) {
      let value = window.localStorage.getItem(this.getMemoryKey(key));
      if (value) {
        try {
          return JSON.parse(value)
        } catch(e) {}
      }
    }

    forget(key) {
      window.localStorage.removeItem(this.getMemoryKey(key));
    }
  }

  if (!Array.isArray) {
    Array.isArray = arg =>
      Object.prototype.toString.call(arg) === '[object Array]';
  }

  const isArray = Array.isArray;

  const BVRL = '__BV_root_listeners__';

  var listenOnRootMixin = {
    methods: {
      /**
       * Safely register event listeners on the root Vue node.
       * While Vue automatically removes listeners for individual components,
       * when a component registers a listener on root and is destroyed,
       * this orphans a callback because the node is gone,
       * but the root does not clear the callback.
       *
       * This adds a non-reactive prop to a vm on the fly
       * in order to avoid object observation and its performance costs
       * to something that needs no reactivity.
       * It should be highly unlikely there are any naming collisions.
       * @param {string} event
       * @param {function} callback
       * @chainable
       */
      listenOnRoot(event, callback) {
        if (!this[BVRL] || !isArray(this[BVRL])) {
          this[BVRL] = [];
        }
        this[BVRL].push({ event, callback });
        this.$root.$on(event, callback);
        return this
      },

      /**
       * Convenience method for calling vm.$emit on vm.$root.
       * @param {string} event
       * @param {*} args
       * @chainable
       */
      emitOnRoot(event, ...args) {
        this.$root.$emit(event, ...args);
        return this
      }
    },

    beforeDestroy() {
      if (this[BVRL] && isArray(this[BVRL])) {
        while (this[BVRL].length > 0) {
          // shift to process in order
          const { event, callback } = this[BVRL].shift();
          this.$root.$off(event, callback);
        }
      }
    }
  };

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script = {
    props: {
      id: {
        type: String,
        required: true
      },
      title: {
        type: String,
        required: true
      }
    },
    methods: {
      emit(event) {
        this.$emit(event, this.collapseId);
      }
    },
    computed: {
      collapseId() {
        return `settings-${this.id}`
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-card',{staticClass:"mb-1",attrs:{"no-body":""}},[_c('b-card-header',{directives:[{name:"b-toggle",rawName:"v-b-toggle",value:(_vm.collapseId),expression:"collapseId"}],attrs:{"role":"tab"}},[_c('h5',{staticClass:"card-title",domProps:{"textContent":_vm._s(_vm.title)}})]),_vm._v(" "),_c('b-collapse',{attrs:{"id":_vm.collapseId,"visible":"","accordion":"settings","role":"tabpanel"},on:{"show":function($event){return _vm.emit('show')},"shown":function($event){return _vm.emit('shown')},"hide":function($event){return _vm.emit('hide')},"hidden":function($event){return _vm.emit('hidden')}}},[_c('b-card-body',[_vm._t("default")],2)],1)],1)};
  var __vue_staticRenderFns__ = [];

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__ = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      false,
      undefined,
      undefined,
      undefined
    );

  // SSR safe client-side ID attribute generation
  // ID's can only be generated client-side, after mount
  // `this._uid` is not synched between server and client
  // @vue/component
  var idMixin = {
    props: {
      id: {
        type: String // default: null

      }
    },
    data: function data() {
      return {
        localId_: null
      };
    },
    computed: {
      safeId: function safeId() {
        // Computed property that returns a dynamic function for creating the ID
        // Reacts to changes in both `.id` and `.localId_` and regenerates a new function
        var id = this.id || this.localId_; // We return a function that accepts an optional suffix string
        // So this computed prop looks and works like a method
        // but benefits from Vue's computed prop caching

        var fn = function fn(suffix) {
          if (!id) {
            return null;
          }

          suffix = String(suffix || '').replace(/\s+/g, '_');
          return suffix ? id + '_' + suffix : id;
        };

        return fn;
      }
    },
    mounted: function mounted() {
      var _this = this;

      // `mounted()` only occurs client-side
      this.$nextTick(function () {
        // Update DOM with auto-generated ID after mount
        // to prevent SSR hydration errors
        _this.localId_ = "__BVID__".concat(_this._uid);
      });
    }
  };

  /**
   * Utilities to get information about the current environment
   */
  // --- Constants ---
  var hasWindowSupport = typeof window !== 'undefined';
  var hasDocumentSupport = typeof document !== 'undefined';
  var hasNavigatorSupport = typeof navigator !== 'undefined';
  var isBrowser = hasWindowSupport && hasDocumentSupport && hasNavigatorSupport; // Browser type sniffing

  var userAgent = isBrowser ? window.navigator.userAgent.toLowerCase() : '';
  var isJSDOM = userAgent.indexOf('jsdom') > 0;
  var isIE = /msie|trident/.test(userAgent); // Determine if the browser supports the option passive for events

  var hasPassiveEventSupport = function () {
    var passiveEventSupported = false;

    if (isBrowser) {
      try {
        var options = {
          get passive() {
            // This function will be called when the browser
            // attempts to access the passive property.

            /* istanbul ignore next: will never be called in JSDOM */
            passiveEventSupported = true;
          }

        };
        window.addEventListener('test', options, options);
        window.removeEventListener('test', options, options);
      } catch (err) {
        /* istanbul ignore next: will never be called in JSDOM */
        passiveEventSupported = false;
      }
    }

    return passiveEventSupported;
  }();

  var getEnv = function getEnv(key) {
    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var env = typeof process !== 'undefined' && process ? process.env || {} : {};

    if (!key) {
      /* istanbul ignore next */
      return env;
    }

    return env[key] || fallback;
  };
  var getNoWarn = function getNoWarn() {
    return getEnv('BOOTSTRAP_VUE_NO_WARN') || getEnv('NODE_ENV') === 'production';
  };

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  var toType = function toType(val) {
    return _typeof(val);
  };
  var isUndefined = function isUndefined(val) {
    return val === undefined;
  };
  var isNull = function isNull(val) {
    return val === null;
  };
  var isUndefinedOrNull = function isUndefinedOrNull(val) {
    return isUndefined(val) || isNull(val);
  };
  var isFunction = function isFunction(val) {
    return toType(val) === 'function';
  };
  var isBoolean = function isBoolean(val) {
    return toType(val) === 'boolean';
  };
  var isArray$1 = function isArray(val) {
    return Array.isArray(val);
  }; // Quick object check
  // This is primarily used to tell Objects from primitive values
  // when we know the value is a JSON-compliant type
  // Note object could be a complex type like array, Date, etc.

  var isObject = function isObject(obj) {
    return obj !== null && _typeof(obj) === 'object';
  }; // Strict object type check
  // Only returns true for plain JavaScript objects

  var isPlainObject = function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  };

  // Loose YYYY-MM-DD matching, ignores any appended time inforation
  var RX_ARRAY_NOTATION = /\[(\d+)]/g;
  var RX_HTML_TAGS = /(<([^>]+)>)/gi;

  var w = hasWindowSupport ? window : {};
  var d = hasDocumentSupport ? document : {};
  var elProto = typeof Element !== 'undefined' ? Element.prototype : {}; // --- Normalization utils ---
  // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill

  /* istanbul ignore next */

  var matchesEl = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector; // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest

  /* istanbul ignore next: JSDOM always returns the first option */

  var requestAF = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.mozRequestAnimationFrame || w.msRequestAnimationFrame || w.oRequestAnimationFrame || // Fallback, but not a true polyfill
  // Only needed for Opera Mini

  /* istanbul ignore next */
  function (cb) {
    return setTimeout(cb, 16);
  };

  var isElement = function isElement(el) {
    return !!(el && el.nodeType === Node.ELEMENT_NODE);
  }; // Get the currently active HTML element

  var getActiveElement = function getActiveElement() {
    var excludes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var activeElement = d.activeElement;
    return activeElement && !excludes.some(function (el) {
      return el === activeElement;
    }) ? activeElement : null;
  }; // Returns `true` if a tag's name equals `name`

  var isActiveElement = function isActiveElement(el) {
    return isElement(el) && el === getActiveElement();
  }; // Determine if an HTML element is visible - Faster than CSS check

  var isVisible = function isVisible(el) {
    if (!isElement(el) || !el.parentNode || !contains(d.body, el)) {
      // Note this can fail for shadow dom elements since they
      // are not a direct descendant of document.body
      return false;
    }

    if (getStyle(el, 'display') === 'none') {
      // We do this check to help with vue-test-utils when using v-show

      /* istanbul ignore next */
      return false;
    } // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(
    // So any tests that need isVisible will fail in JSDOM
    // Except when we override the getBCR prototype in some tests


    var bcr = getBCR(el);
    return !!(bcr && bcr.height > 0 && bcr.width > 0);
  }; // Determine if an element is disabled

  var select = function select(selector, root) {
    return (isElement(root) ? root : d).querySelector(selector) || null;
  }; // Determine if an element matches a selector

  var matches = function matches(el, selector) {
    return isElement(el) ? matchesEl.call(el, selector) : false;
  }; // Finds closest element matching selector. Returns `null` if not found

  var contains = function contains(parent, child) {
    return parent && isFunction(parent.contains) ? parent.contains(child) : false;
  }; // Get an element given an ID
  // Returns `null` if not found

  var getStyle = function getStyle(el, prop) {
    return prop && isElement(el) ? el.style[prop] || null : null;
  }; // Return the Bounding Client Rect of an element
  // Returns `null` if not an element

  /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */

  var getBCR = function getBCR(el) {
    return isElement(el) ? el.getBoundingClientRect() : null;
  }; // Get computed style object for an element

  var attemptFocus = function attemptFocus(el) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
      el.focus(options);
    } catch (_unused) {}

    return isActiveElement(el);
  }; // Attempt to blur an element, and return `true` if successful

  var SELECTOR = 'input, textarea, select'; // @vue/component

  var formMixin = {
    props: {
      name: {
        type: String // default: undefined

      },
      id: {
        type: String // default: undefined

      },
      disabled: {
        type: Boolean
      },
      required: {
        type: Boolean,
        default: false
      },
      form: {
        type: String // default: null

      },
      autofocus: {
        type: Boolean,
        default: false
      }
    },
    mounted: function mounted() {
      this.handleAutofocus();
    },

    /* istanbul ignore next */
    activated: function activated() {
      this.handleAutofocus();
    },
    methods: {
      handleAutofocus: function handleAutofocus() {
        var _this = this;

        this.$nextTick(function () {
          requestAF(function () {
            var el = _this.$el;

            if (_this.autofocus && isVisible(el)) {
              if (!matches(el, SELECTOR)) {
                el = select(SELECTOR, el);
              }

              attemptFocus(el);
            }
          });
        });
      }
    }
  };

  var identity = function identity(x) {
    return x;
  };

  /**
   * Get property defined by dot/array notation in string, returns undefined if not found
   *
   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901
   *
   * @param {Object} obj
   * @param {string|Array} path
   * @return {*}
   */

  var getRaw = function getRaw(obj, path) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    // Handle array of path values
    path = isArray$1(path) ? path.join('.') : path; // If no path or no object passed

    if (!path || !isObject(obj)) {
      return defaultValue;
    } // Handle edge case where user has dot(s) in top-level item field key
    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762
    // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters
    // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463


    if (path in obj) {
      return obj[path];
    } // Handle string array notation (numeric indices only)


    path = String(path).replace(RX_ARRAY_NOTATION, '.$1');
    var steps = path.split('.').filter(identity); // Handle case where someone passes a string of only dots

    if (steps.length === 0) {
      return defaultValue;
    } // Traverse path in object to find result
    // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters
    // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463


    return steps.every(function (step) {
      return isObject(obj) && step in obj && !isUndefinedOrNull(obj = obj[step]);
    }) ? obj : isNull(obj) ? null : defaultValue;
  };
  /**
   * Get property defined by dot/array notation in string.
   *
   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901
   *
   * @param {Object} obj
   * @param {string|Array} path
   * @param {*} defaultValue (optional)
   * @return {*}
   */

  var get = function get(obj, path) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var val = getRaw(obj, path);
    return isUndefinedOrNull(val) ? defaultValue : val;
  };

  var stripTags = function stripTags() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return String(text).replace(RX_HTML_TAGS, '');
  }; // Generate a `domProps` object for either `innerHTML`, `textContent` or an empty object

  var freeze = function freeze(obj) {
    return Object.freeze(obj);
  };
  var keys = function keys(obj) {
    return Object.keys(obj);
  }; // --- "Instance" ---
  /**
   * Deep-freezes and object, making it immutable / read-only
   * Returns the same object passed-in, but frozen
   * Freezes inner object/array/values first
   * Note: This method will not work for property values using `Symbol()` as a key
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */

  var deepFreeze = function deepFreeze(obj) {
    // Retrieve the property names defined on object/array
    // Note: `keys` will ignore properties that are keyed by a `Symbol()`
    var props = keys(obj); // Iterate over each prop and recursively freeze it

    props.forEach(function (prop) {
      var value = obj[prop]; // If value is a plain object or array, we deepFreeze it

      obj[prop] = value && (isPlainObject(value) || isArray$1(value)) ? deepFreeze(value) : value;
    });
    return freeze(obj);
  };

  /**
   * Log a warning message to the console with BootstrapVue formatting
   * @param {string} message
   */

  var warn = function warn(message)
  /* istanbul ignore next */
  {
    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (!getNoWarn()) {
      console.warn("[BootstrapVue warn]: ".concat(source ? "".concat(source, " - ") : '').concat(message));
    }
  };

  var OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop "options" to an object is deprecated. Use the array format instead.'; // @vue/component

  var formOptionsMixin = {
    props: {
      options: {
        type: [Array, Object],
        default: function _default() {
          return [];
        }
      },
      valueField: {
        type: String,
        default: 'value'
      },
      textField: {
        type: String,
        default: 'text'
      },
      htmlField: {
        type: String,
        default: 'html'
      },
      disabledField: {
        type: String,
        default: 'disabled'
      }
    },
    computed: {
      formOptions: function formOptions() {
        return this.normalizeOptions(this.options);
      }
    },
    methods: {
      normalizeOption: function normalizeOption(option) {
        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // When the option is an object, normalize it
        if (isPlainObject(option)) {
          var value = get(option, this.valueField);
          var text = get(option, this.textField);
          return {
            value: isUndefined(value) ? key || text : value,
            text: stripTags(String(isUndefined(text) ? key : text)),
            html: get(option, this.htmlField),
            disabled: Boolean(get(option, this.disabledField))
          };
        } // Otherwise create an `<option>` object from the given value


        return {
          value: key || option,
          text: stripTags(String(option)),
          disabled: false
        };
      },
      normalizeOptions: function normalizeOptions(options) {
        var _this = this;

        // Normalize the given options array
        if (isArray$1(options)) {
          return options.map(function (option) {
            return _this.normalizeOption(option);
          });
        } else if (isPlainObject(options)) {
          // Deprecate the object options format
          warn(OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name); // Normalize a `options` object to an array of options

          return keys(options).map(function (key) {
            return _this.normalizeOption(options[key] || {}, key);
          });
        } // If not an array or object, return an empty array

        /* istanbul ignore next */


        return [];
      }
    }
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var cloneDeep = function cloneDeep(obj) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;

    if (isArray$1(obj)) {
      return obj.reduce(function (result, val) {
        return [].concat(_toConsumableArray(result), [cloneDeep(val, val)]);
      }, []);
    }

    if (isPlainObject(obj)) {
      return keys(obj).reduce(function (result, key) {
        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, cloneDeep(obj[key], obj[key])));
      }, {});
    }

    return defaultValue;
  };

  var NAME_ALERT = 'BAlert';
  var NAME_AVATAR = 'BAvatar';
  var NAME_BADGE = 'BBadge';
  var NAME_BUTTON = 'BButton';
  var NAME_BUTTON_CLOSE = 'BButtonClose';
  var NAME_CALENDAR = 'BCalendar';
  var NAME_CARD_SUB_TITLE = 'BCardSubTitle';
  var NAME_CAROUSEL = 'BCarousel';
  var NAME_DROPDOWN = 'BDropdown';
  var NAME_FORM_DATEPICKER = 'BFormDatepicker';
  var NAME_FORM_FILE = 'BFormFile';
  var NAME_FORM_RATING = 'BFormRating';
  var NAME_FORM_SPINBUTTON = 'BFormSpinbutton';
  var NAME_FORM_TAG = 'BFormTag';
  var NAME_FORM_TAGS = 'BFormTags';
  var NAME_FORM_TEXT = 'BFormText';
  var NAME_FORM_TIMEPICKER = 'BFormTimepicker';
  var NAME_IMG = 'BImg';
  var NAME_IMG_LAZY = 'BImgLazy';
  var NAME_INPUT_GROUP = 'BInputGroup';
  var NAME_JUMBOTRON = 'BJumbotron';
  var NAME_LINK = 'BLink';
  var NAME_LIST_GROUP_ITEM = 'BListGroupItem';
  var NAME_MODAL = 'BModal';
  var NAME_NAVBAR = 'BNavbar';
  var NAME_NAVBAR_TOGGLE = 'BNavbarToggle';
  var NAME_PAGINATION = 'BPagination';
  var NAME_PAGINATION_NAV = 'BPaginationNav';
  var NAME_POPOVER = 'BPopover';
  var NAME_PROGRESS = 'BProgress';
  var NAME_PROGRESS_BAR = 'BProgressBar';
  var NAME_SIDEBAR = 'BSidebar';
  var NAME_SKELETON = 'BSkeleton';
  var NAME_SKELETON_ICON = 'BSkeletonIcon';
  var NAME_SPINNER = 'BSpinner';
  var NAME_TABLE = 'BTable';
  var NAME_TIME = 'BTime';
  var NAME_TOAST = 'BToast';
  var NAME_TOASTER = 'BToaster';
  var NAME_TOOLTIP = 'BTooltip';

  var _deepFreeze;

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  // NOTES
  //
  // The global config SHALL NOT be used to set defaults for Boolean props, as the props
  // would loose their semantic meaning, and force people writing 3rd party components to
  // explicitly set a true or false value using the v-bind syntax on boolean props
  //
  // Supported config values (depending on the prop's supported type(s)):
  // `String`, `Array`, `Object`, `null` or `undefined`
  // BREAKPOINT DEFINITIONS
  //
  // Some components (`<b-col>` and `<b-form-group>`) generate props based on breakpoints,
  // and this occurs when the component is first loaded (evaluated), which may happen
  // before the config is created/modified
  //
  // To get around this we make these components' props async (lazy evaluation)
  // The component definition is only called/executed when the first access to the
  // component is used (and cached on subsequent uses)
  // PROP DEFAULTS
  //
  // For default values on props, we use the default value factory function approach so
  // that the default values are pulled in at each component instantiation
  //
  //  props: {
  //    variant: {
  //      type: String,
  //      default: () => getConfigComponent('BAlert', 'variant')
  //    }
  //  }
  //
  // We also provide a cached getter for breakpoints, which are "frozen" on first access
  // prettier-ignore

  var DEFAULTS = deepFreeze((_deepFreeze = {
    // Breakpoints
    breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],
    // Form controls
    formControls: {
      size: undefined
    }
  }, _defineProperty$1(_deepFreeze, NAME_ALERT, {
    dismissLabel: 'Close',
    variant: 'info'
  }), _defineProperty$1(_deepFreeze, NAME_AVATAR, {
    variant: 'secondary',
    badgeVariant: 'primary'
  }), _defineProperty$1(_deepFreeze, NAME_BADGE, {
    variant: 'secondary'
  }), _defineProperty$1(_deepFreeze, NAME_BUTTON, {
    size: undefined,
    variant: 'secondary'
  }), _defineProperty$1(_deepFreeze, NAME_BUTTON_CLOSE, {
    content: '&times;',
    // `textVariant` is `undefined` to inherit the current text color
    textVariant: undefined,
    ariaLabel: 'Close'
  }), _defineProperty$1(_deepFreeze, NAME_CALENDAR, {
    selectedVariant: 'primary',
    // Defaults to `selectedVariant`
    todayVariant: undefined,
    navButtonVariant: 'secondary',
    // BFormDate will choose these first if not provided in BFormDate section
    labelPrevDecade: 'Previous decade',
    labelPrevYear: 'Previous year',
    labelPrevMonth: 'Previous month',
    labelCurrentMonth: 'Current month',
    labelNextMonth: 'Next month',
    labelNextYear: 'Next year',
    labelNextDecade: 'Next decade',
    labelToday: 'Today',
    labelSelected: 'Selected date',
    labelNoDateSelected: 'No date selected',
    labelCalendar: 'Calendar',
    labelNav: 'Calendar navigation',
    labelHelp: 'Use cursor keys to navigate calendar dates'
  }), _defineProperty$1(_deepFreeze, NAME_CARD_SUB_TITLE, {
    // `<b-card>` and `<b-card-body>` also inherit this prop
    subTitleTextVariant: 'muted'
  }), _defineProperty$1(_deepFreeze, NAME_CAROUSEL, {
    labelPrev: 'Previous Slide',
    labelNext: 'Next Slide',
    labelGotoSlide: 'Goto Slide',
    labelIndicators: 'Select a slide to display'
  }), _defineProperty$1(_deepFreeze, NAME_DROPDOWN, {
    toggleText: 'Toggle Dropdown',
    size: undefined,
    variant: 'secondary',
    splitVariant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_FORM_DATEPICKER, {
    // BFormDatepicker will choose from BCalendar first if not provided here
    selectedVariant: undefined,
    todayVariant: undefined,
    navButtonVariant: undefined,
    labelPrevDecade: undefined,
    labelPrevYear: undefined,
    labelPrevMonth: undefined,
    labelCurrentMonth: undefined,
    labelNextMonth: undefined,
    labelNextYear: undefined,
    labelNextDecade: undefined,
    labelToday: undefined,
    labelSelected: undefined,
    labelNoDateSelected: undefined,
    labelCalendar: undefined,
    labelNav: undefined,
    labelHelp: undefined,
    // These props are specific to BFormDatepicker
    labelTodayButton: 'Select today',
    labelResetButton: 'Reset',
    labelCloseButton: 'Close'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_FILE, {
    browseText: 'Browse',
    // Chrome default file prompt
    placeholder: 'No file chosen',
    dropPlaceholder: 'Drop files here',
    noDropPlaceholder: 'Not allowed'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_RATING, {
    variant: null,
    color: null
  }), _defineProperty$1(_deepFreeze, NAME_FORM_TAG, {
    removeLabel: 'Remove tag',
    variant: 'secondary'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_TAGS, {
    addButtonText: 'Add',
    addButtonVariant: 'outline-secondary',
    duplicateTagText: 'Duplicate tag(s)',
    invalidTagText: 'Invalid tag(s)',
    limitTagsText: 'Tag limit reached',
    placeholder: 'Add tag...',
    tagRemoveLabel: 'Remove tag',
    tagRemovedLabel: 'Tag removed',
    tagVariant: 'secondary'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_TEXT, {
    textVariant: 'muted'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_TIMEPICKER, {
    // Fallback to BTime
    labelNoTimeSelected: undefined,
    labelSelected: undefined,
    labelHours: undefined,
    labelMinutes: undefined,
    labelSeconds: undefined,
    labelAmpm: undefined,
    labelAm: undefined,
    labelPm: undefined,
    // Fallback to BTime then BFormSpinbutton
    labelDecrement: undefined,
    labelIncrement: undefined,
    // These props are specific to BFormTimepicker
    labelNowButton: 'Select now',
    labelResetButton: 'Reset',
    labelCloseButton: 'Close'
  }), _defineProperty$1(_deepFreeze, NAME_FORM_SPINBUTTON, {
    labelDecrement: 'Decrement',
    labelIncrement: 'Increment'
  }), _defineProperty$1(_deepFreeze, NAME_IMG, {
    blankColor: 'transparent'
  }), _defineProperty$1(_deepFreeze, NAME_IMG_LAZY, {
    blankColor: 'transparent'
  }), _defineProperty$1(_deepFreeze, NAME_INPUT_GROUP, {
    size: undefined
  }), _defineProperty$1(_deepFreeze, NAME_JUMBOTRON, {
    bgVariant: undefined,
    borderVariant: undefined,
    textVariant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_LINK, {
    routerComponentName: undefined
  }), _defineProperty$1(_deepFreeze, NAME_LIST_GROUP_ITEM, {
    variant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_MODAL, {
    titleTag: 'h5',
    size: 'md',
    headerBgVariant: undefined,
    headerBorderVariant: undefined,
    headerTextVariant: undefined,
    headerCloseVariant: undefined,
    bodyBgVariant: undefined,
    bodyTextVariant: undefined,
    footerBgVariant: undefined,
    footerBorderVariant: undefined,
    footerTextVariant: undefined,
    cancelTitle: 'Cancel',
    cancelVariant: 'secondary',
    okTitle: 'OK',
    okVariant: 'primary',
    headerCloseContent: '&times;',
    headerCloseLabel: 'Close'
  }), _defineProperty$1(_deepFreeze, NAME_NAVBAR, {
    variant: null
  }), _defineProperty$1(_deepFreeze, NAME_NAVBAR_TOGGLE, {
    label: 'Toggle navigation'
  }), _defineProperty$1(_deepFreeze, NAME_PAGINATION, {
    size: undefined
  }), _defineProperty$1(_deepFreeze, NAME_PAGINATION_NAV, {
    size: undefined
  }), _defineProperty$1(_deepFreeze, NAME_POPOVER, {
    boundary: 'scrollParent',
    boundaryPadding: 5,
    customClass: undefined,
    delay: 50,
    variant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_PROGRESS, {
    variant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_PROGRESS_BAR, {
    variant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_SPINNER, {
    variant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_SKELETON, {
    animation: 'wave'
  }), _defineProperty$1(_deepFreeze, NAME_SKELETON_ICON, {
    animation: 'wave'
  }), _defineProperty$1(_deepFreeze, NAME_SIDEBAR, {
    bgVariant: 'light',
    textVariant: 'dark',
    shadow: false,
    width: undefined,
    tag: 'div',
    backdropVariant: 'dark'
  }), _defineProperty$1(_deepFreeze, NAME_TABLE, {
    selectedVariant: 'active',
    headVariant: undefined,
    footVariant: undefined
  }), _defineProperty$1(_deepFreeze, NAME_TIME, {
    labelNoTimeSelected: 'No time selected',
    labelSelected: 'Selected time',
    labelHours: 'Hours',
    labelMinutes: 'Minutes',
    labelSeconds: 'Seconds',
    labelAmpm: 'AM/PM',
    // It would be nice to be able to get these from Intl.DateTimeFormat somehow
    labelAm: 'AM',
    labelPm: 'PM',
    // The following inherit from BFormSpinbutton if not provided
    labelIncrement: undefined,
    labelDecrement: undefined
  }), _defineProperty$1(_deepFreeze, NAME_TOAST, {
    toaster: 'b-toaster-top-right',
    autoHideDelay: 5000,
    variant: undefined,
    toastClass: undefined,
    headerClass: undefined,
    bodyClass: undefined
  }), _defineProperty$1(_deepFreeze, NAME_TOASTER, {
    ariaLive: undefined,
    ariaAtomic: undefined,
    role: undefined
  }), _defineProperty$1(_deepFreeze, NAME_TOOLTIP, {
    boundary: 'scrollParent',
    boundaryPadding: 5,
    customClass: undefined,
    delay: 50,
    variant: undefined
  }), _deepFreeze));

  var PROP_NAME = '$bvConfig';
  var VueProto = Vue__default['default'].prototype; // --- Getter methods ---

  var getConfigValue = function getConfigValue(key) {
    return VueProto[PROP_NAME] ? VueProto[PROP_NAME].getConfigValue(key) : cloneDeep(getRaw(DEFAULTS, key));
  }; // Method to grab a config value for a particular component

  var getComponentConfig = function getComponentConfig(cmpName) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // Return the particular config value for key for if specified,
    // otherwise we return the full config (or an empty object if not found)
    return key ? getConfigValue("".concat(cmpName, ".").concat(key)) : getConfigValue(cmpName) || {};
  }; // Convenience method for getting all breakpoint names

  var formSizeMixin = {
    props: {
      size: {
        type: String,
        default: function _default() {
          return getComponentConfig('formControls', 'size');
        }
      }
    },
    computed: {
      sizeFormClass: function sizeFormClass() {
        return [this.size ? "form-control-".concat(this.size) : null];
      },

      /* istanbul ignore next: don't think this is used */
      sizeBtnClass: function sizeBtnClass() {
        return [this.size ? "btn-".concat(this.size) : null];
      }
    }
  };

  /* Form control contextual state class computation
   *
   * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop
   * state can be one of five values:
   *  - true for is-valid
   *  - false for is-invalid
   *  - null for no contextual state
   */

  var formStateMixin = {
    props: {
      state: {
        // Tri-state prop: true, false, null (or undefined)
        type: Boolean,
        default: null
      }
    },
    computed: {
      computedState: function computedState() {
        // If not a boolean, ensure that value is null
        return isBoolean(this.state) ? this.state : null;
      },
      stateClass: function stateClass() {
        var state = this.computedState;
        return state === true ? 'is-valid' : state === false ? 'is-invalid' : null;
      }
    }
  };

  //

  var script$1 = {
    mixins: [idMixin, formMixin, formOptionsMixin, formSizeMixin, formStateMixin],
    model: {
      prop: 'checked',
      event: 'input'
    },
    provide: function provide() {
      return {
        bvRadioGroup: this
      }
    },
    props: {
      validated: {
        type: Boolean,
        default: false
      },
      ariaInvalid: {
        type: [Boolean, String],
        default: false
      },
      stacked: {
        type: Boolean,
        default: false
      },
      plain: {
        type: Boolean,
        default: false
      },
      checked: {
        type: [String, Object, Number, Boolean],
        default: null
      }
    },
    data: function data() {
      return {
        localChecked: this.checked
      }
    },
    computed: {
      isRadioGroup: function isRadioGroup() {
        return true;
      },
      inline: function inline() {
        return !this.stacked;
      },
      groupName: function groupName() {
        // Checks/Radios tied to the same model must have the same name,
        // especially for ARIA accessibility.
        return this.name || this.safeId();
      },
      groupClasses: function groupClasses() {
        return [this.validated ? "was-validated" : ''];
      },
      computedAriaInvalid: function computedAriaInvalid() {
        var ariaInvalid = this.ariaInvalid;

        if (ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === '') {
          return 'true';
        }

        return this.computedState === false ? 'true' : null;
      }
    },
    watch: {
      checked: function checked(newVal, oldVal) {
        this.localChecked = newVal;
      },
      localChecked: function localChecked(newVal, oldVal) {
        this.$emit('input', newVal);
      }
    }
  };

  function normalizeComponent$1(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent$1;

  /* script */
  var __vue_script__$1 = script$1;
  /* template */
  var __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"row no-gutters flex-nowrap form-image-group",class:_vm.groupClasses,attrs:{"aria-required":_vm.required,"aria-invalid":_vm.computedAriaInvalid,"role":_vm.isRadioGroup ? 'radiogroup' : 'group',"tabindex":"-1"}},_vm._l((_vm.options),function(item,idx){return _c('div',{key:(_vm.name + "-" + (item.value)),staticClass:"col",class:{ 'ml-2': idx > 0 }},[_c('b-form-radio',{attrs:{"id":(_vm.name + "-" + (item.value)),"value":item.value,"disabled":item.disabled,"required":Boolean(_vm.name && _vm.required),"name":_vm.name}},[_c('b-img',{attrs:{"src":item.image,"alt":item.text,"fluid":""}})],1)],1)}),0)};
  var __vue_staticRenderFns__$1 = [];

    /* style */
    var __vue_inject_styles__$1 = undefined;
    /* scoped */
    var __vue_scope_id__$1 = undefined;
    /* module identifier */
    var __vue_module_identifier__$1 = undefined;
    /* functional template */
    var __vue_is_functional_template__$1 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var BvFormImageGroup = normalizeComponent_1(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      undefined,
      undefined
    );

  // import 'fmv-layout/dist/fmv-layout.css'

  var script$2 = {
    mixins: [
      listenOnRootMixin,
    ],
    components: {
      Collapse: __vue_component__,
      FormImageGroup: BvFormImageGroup
    },
    data() {
      return {
        session: null,
        settings: {},
      }
    },
    props: {
      namespace: {
        type: String,
        default: null
      },
      options: {
        type: Array,
        required: true
      },
      debug: {
        type: Boolean,
        default: false
      }
    },
    watch: {
      settings: {
        deep: true,
        handler(value) {
          this.setSettings();
        }
      }
    },
    mounted() {
      this.session = new Session(this.namespace);
      this.initSettings();
      this.listenOnRoot('fm:settings:update', this.onUpdate);
    },
    methods: {
      onUpdate(settings) {
        Object.keys(settings).map(key => {
          this.$set(this.settings, key, settings[key]);
        });
      },
      initSettings() {
        let memory = this.session.memory('settings');

        this.options.forEach(option => {
          option.children.forEach(group => {
            if (this.settings[`${option.id}.${group.id}`] === undefined) {
              let value;

              if (group.cookies === undefined || group.cookies !== false) {
                try {
                  value = memory[`${option.id}.${group.id}`];
                } catch(e) {}
              }
              
              const def = group.options.find(o => o.selected === true);
              if (!value && def !== undefined) {
                value = def.value;
              }
              if (!value && value !== false) {
                value = group.options[0].value;
              }

              this.$set(this.settings, `${option.id}.${group.id}`, value);
            }
          });
        });
      },
      setSettings(reload) {
        this.session.save('settings', this.settings);

        this.$root.$emit('fm:settings:state', this.settings);

        if (reload) {
          location.reload();
        }
      }
    }
  };

  /* script */
  const __vue_script__$2 = script$2;

  /* template */

    /* style */
    const __vue_inject_styles__$2 = undefined;
    /* scoped */
    const __vue_scope_id__$2 = undefined;
    /* module identifier */
    const __vue_module_identifier__$2 = undefined;
    /* functional template */
    const __vue_is_functional_template__$2 = undefined;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
      {},
      __vue_inject_styles__$2,
      __vue_script__$2,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      false,
      undefined,
      undefined,
      undefined
    );

  //
  const { drawerProps, sidebarProps, prefixProps } = fmvLayout.utils;

  var script$3 = {
    components: {
      FmvDrawer: fmvLayout.FmvDrawer,
      FmvSidebar: fmvLayout.FmvSidebar
    },
    extends: __vue_component__$1,
    props: {
      ...prefixProps(drawerProps, 'drawer'),
      ...prefixProps(sidebarProps, 'sidebar')
    },
    computed: {
      localAlign() {
        if (this.mainDrawerAlign) {
          return this.mainDrawerAlign === 'end' ? 'left' : 'right'
        }
        return this.drawerAlign
      },
      localSidebarVariant() {
        return this.sidebarVariant || 'sidebar-transparent-xs-up'
      }
    }
  };

  const isOldIE = typeof navigator !== 'undefined' &&
      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  function createInjector(context) {
      return (id, style) => addStyle(id, style);
  }
  let HEAD;
  const styles = {};
  function addStyle(id, css) {
      const group = isOldIE ? css.media || 'default' : id;
      const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
      if (!style.ids.has(id)) {
          style.ids.add(id);
          let code = css.source;
          if (css.map) {
              // https://developer.chrome.com/devtools/docs/javascript-debugging
              // this makes source maps inside style tags work properly in Chrome
              code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
              // http://stackoverflow.com/a/26603875
              code +=
                  '\n/*# sourceMappingURL=data:application/json;base64,' +
                      btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                      ' */';
          }
          if (!style.element) {
              style.element = document.createElement('style');
              style.element.type = 'text/css';
              if (css.media)
                  style.element.setAttribute('media', css.media);
              if (HEAD === undefined) {
                  HEAD = document.head || document.getElementsByTagName('head')[0];
              }
              HEAD.appendChild(style.element);
          }
          if ('styleSheet' in style.element) {
              style.styles.push(code);
              style.element.styleSheet.cssText = style.styles
                  .filter(Boolean)
                  .join('\n');
          }
          else {
              const index = style.ids.size - 1;
              const textNode = document.createTextNode(code);
              const nodes = style.element.childNodes;
              if (nodes[index])
                  style.element.removeChild(nodes[index]);
              if (nodes.length)
                  style.element.insertBefore(textNode, nodes[index]);
              else
                  style.element.appendChild(textNode);
          }
      }
  }

  /* script */
  const __vue_script__$3 = script$3;

  /* template */
  var __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('fmv-drawer',{attrs:{"id":"settings","align":_vm.localAlign}},[_c('fmv-sidebar',{attrs:{"align":_vm.localAlign,"type":_vm.sidebarType,"variant":_vm.localSidebarVariant}},[_c('div',{staticClass:"p-2"},[_vm._l((_vm.options),function(option){return (option.visible !== false)?_c('collapse',{key:("collapse-" + (option.id)),attrs:{"id":option.id,"title":option.title}},_vm._l((option.children),function(group,index){return (group.visible !== false)?_c('b-form-group',{key:("group-" + (option.id) + "-" + index),class:{ 'mb-0': index === option.children.length - 1 },attrs:{"label":group.title}},[(group.component === 'form-image-group')?_c('form-image-group',{attrs:{"options":group.options,"name":group.id},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}}):_vm._e(),_vm._v(" "),(group.component === 'b-form-radio-group')?_c('b-form-radio-group',{attrs:{"id":("group-" + (option.id) + "-" + index),"options":group.options},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}}):_vm._e(),_vm._v(" "),(group.component === 'b-form-checkbox')?_c('b-form-checkbox',{attrs:{"id":("group-" + (option.id) + "-" + index)},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}},[_vm._v("\n            "+_vm._s(group.title)+"\n          ")]):_vm._e(),_vm._v(" "),(group.component === 'custom-checkbox-toggle')?_c('b-form-checkbox',{staticClass:"custom-checkbox-toggle custom-control-inline mr-1",attrs:{"id":("group-" + (option.id) + "-" + index)},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}},[_vm._v(" ")]):_vm._e(),_vm._v(" "),(group.component === 'b-form-select')?_c('b-form-select',{attrs:{"id":("group-" + (option.id) + "-" + index),"options":group.options},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}}):_vm._e(),_vm._v(" "),(group.component === 'custom-checkbox-toggle')?_c('label',{staticClass:"mb-0",attrs:{"for":("group-" + (option.id) + "-" + index)}},[_c('span',{staticClass:"form-label m-0"},[_vm._v(_vm._s(group.title))])]):_vm._e()],1):_vm._e()}),1):_vm._e()}),_vm._v(" "),_vm._t("default"),_vm._v(" "),(_vm.debug)?_c('pre',{domProps:{"textContent":_vm._s(_vm.settings)}}):_vm._e()],2)])],1)};
  var __vue_staticRenderFns__$2 = [];

    /* style */
    const __vue_inject_styles__$3 = function (inject) {
      if (!inject) return
      inject("data-v-76379733_0", { source: "#settings .mdk-drawer__content{width:300px}#settings .mdk-drawer__scrim{background-color:rgba(56,59,61,.5)}#settings .col-form-label{font-size:.75rem;text-transform:uppercase;color:#b8bdc2;line-height:1rem;font-weight:500}", map: undefined, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$3 = undefined;
    /* module identifier */
    const __vue_module_identifier__$3 = undefined;
    /* functional template */
    const __vue_is_functional_template__$3 = false;
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$2 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
      __vue_inject_styles__$3,
      __vue_script__$3,
      __vue_scope_id__$3,
      __vue_is_functional_template__$3,
      __vue_module_identifier__$3,
      false,
      createInjector,
      undefined,
      undefined
    );

  /* script */

  /* template */
  var __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{staticClass:"material-icons"},[_vm._t("default",[_vm._v("credit_card")])],2)};
  var __vue_staticRenderFns__$3 = [];

    /* style */
    const __vue_inject_styles__$4 = undefined;
    /* scoped */
    const __vue_scope_id__$4 = undefined;
    /* module identifier */
    const __vue_module_identifier__$4 = undefined;
    /* functional template */
    const __vue_is_functional_template__$4 = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$3 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
      __vue_inject_styles__$4,
      {},
      __vue_scope_id__$4,
      __vue_is_functional_template__$4,
      __vue_module_identifier__$4,
      false,
      undefined,
      undefined,
      undefined
    );

  //
  var script$4 = {
    components: {
      MdIcon: __vue_component__$3
    },
    props: {
      align: {
        type: String,
        default: 'right'
      },
      variant: {
        type: String,
        default: 'dark'
      }
    },
    computed: {
      localAlign() {
        if (this.mainDrawerAlign) {
          return this.mainDrawerAlign === 'end' ? 'left' : 'right'
        }
        return this.align
      },
      buttonClass() {
        return ['app-settings-button', `app-settings-button--${this.localAlign}`]
      }
    }
  };

  /* script */
  const __vue_script__$4 = script$4;

  /* template */
  var __vue_render__$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-btn',{directives:[{name:"fmv-toggle",rawName:"v-fmv-toggle.settings",modifiers:{"settings":true}}],class:_vm.buttonClass,attrs:{"variant":_vm.variant}},[_c('md-icon',[_vm._v("settings")])],1)};
  var __vue_staticRenderFns__$4 = [];

    /* style */
    const __vue_inject_styles__$5 = function (inject) {
      if (!inject) return
      inject("data-v-a69951d2_0", { source: ".app-settings-button[data-v-a69951d2]{position:fixed;top:100px}.app-settings-button--right[data-v-a69951d2]{right:0;border-top-right-radius:0;border-bottom-right-radius:0}.app-settings-button--left[data-v-a69951d2]{left:0;border-top-left-radius:0;border-bottom-left-radius:0}", map: undefined, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$5 = "data-v-a69951d2";
    /* module identifier */
    const __vue_module_identifier__$5 = undefined;
    /* functional template */
    const __vue_is_functional_template__$5 = false;
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$4 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
      __vue_inject_styles__$5,
      __vue_script__$4,
      __vue_scope_id__$5,
      __vue_is_functional_template__$5,
      __vue_module_identifier__$5,
      false,
      createInjector,
      undefined,
      undefined
    );

  // Customized for this use-case
  const isObject$1 = value =>
  	typeof value === 'object' &&
  	value !== null &&
  	!(value instanceof RegExp) &&
  	!(value instanceof Error) &&
  	!(value instanceof Date);

  const mapObject = (object, fn, options, isSeen = new WeakMap()) => {
  	options = Object.assign({
  		deep: false,
  		target: {}
  	}, options);

  	if (isSeen.has(object)) {
  		return isSeen.get(object);
  	}

  	isSeen.set(object, options.target);

  	const {target} = options;
  	delete options.target;

  	const mapArray = array => array.map(x => isObject$1(x) ? mapObject(x, fn, options, isSeen) : x);
  	if (Array.isArray(object)) {
  		return mapArray(object);
  	}

  	/// TODO: Use `Object.entries()` when targeting Node.js 8
  	for (const key of Object.keys(object)) {
  		const value = object[key];
  		let [newKey, newValue] = fn(key, value, object);

  		if (options.deep && isObject$1(newValue)) {
  			newValue = Array.isArray(newValue) ?
  				mapArray(newValue) :
  				mapObject(newValue, fn, options, isSeen);
  		}

  		target[newKey] = newValue;
  	}

  	return target;
  };

  var mapObj = mapObject;

  const preserveCamelCase = string => {
  	let isLastCharLower = false;
  	let isLastCharUpper = false;
  	let isLastLastCharUpper = false;

  	for (let i = 0; i < string.length; i++) {
  		const character = string[i];

  		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
  			string = string.slice(0, i) + '-' + string.slice(i);
  			isLastCharLower = false;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = true;
  			i++;
  		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
  			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = false;
  			isLastCharLower = true;
  		} else {
  			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
  		}
  	}

  	return string;
  };

  const camelCase = (input, options) => {
  	if (!(typeof input === 'string' || Array.isArray(input))) {
  		throw new TypeError('Expected the input to be `string | string[]`');
  	}

  	options = Object.assign({
  		pascalCase: false
  	}, options);

  	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

  	if (Array.isArray(input)) {
  		input = input.map(x => x.trim())
  			.filter(x => x.length)
  			.join('-');
  	} else {
  		input = input.trim();
  	}

  	if (input.length === 0) {
  		return '';
  	}

  	if (input.length === 1) {
  		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
  	}

  	const hasUpperCase = input !== input.toLowerCase();

  	if (hasUpperCase) {
  		input = preserveCamelCase(input);
  	}

  	input = input
  		.replace(/^[_.\- ]+/, '')
  		.toLowerCase()
  		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
  		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

  	return postProcess(input);
  };

  var camelcase = camelCase;
  // TODO: Remove this for the next major release
  var _default = camelCase;
  camelcase.default = _default;

  class QuickLRU {
  	constructor(opts) {
  		opts = Object.assign({}, opts);

  		if (!(opts.maxSize && opts.maxSize > 0)) {
  			throw new TypeError('`maxSize` must be a number greater than 0');
  		}

  		this.maxSize = opts.maxSize;
  		this.cache = new Map();
  		this.oldCache = new Map();
  		this._size = 0;
  	}

  	_set(key, value) {
  		this.cache.set(key, value);
  		this._size++;

  		if (this._size >= this.maxSize) {
  			this._size = 0;
  			this.oldCache = this.cache;
  			this.cache = new Map();
  		}
  	}

  	get(key) {
  		if (this.cache.has(key)) {
  			return this.cache.get(key);
  		}

  		if (this.oldCache.has(key)) {
  			const value = this.oldCache.get(key);
  			this._set(key, value);
  			return value;
  		}
  	}

  	set(key, value) {
  		if (this.cache.has(key)) {
  			this.cache.set(key, value);
  		} else {
  			this._set(key, value);
  		}

  		return this;
  	}

  	has(key) {
  		return this.cache.has(key) || this.oldCache.has(key);
  	}

  	peek(key) {
  		if (this.cache.has(key)) {
  			return this.cache.get(key);
  		}

  		if (this.oldCache.has(key)) {
  			return this.oldCache.get(key);
  		}
  	}

  	delete(key) {
  		if (this.cache.delete(key)) {
  			this._size--;
  		}

  		this.oldCache.delete(key);
  	}

  	clear() {
  		this.cache.clear();
  		this.oldCache.clear();
  		this._size = 0;
  	}

  	* keys() {
  		for (const el of this) {
  			yield el[0];
  		}
  	}

  	* values() {
  		for (const el of this) {
  			yield el[1];
  		}
  	}

  	* [Symbol.iterator]() {
  		for (const el of this.cache) {
  			yield el;
  		}

  		for (const el of this.oldCache) {
  			if (!this.cache.has(el[0])) {
  				yield el;
  			}
  		}
  	}

  	get size() {
  		let oldCacheSize = 0;
  		for (const el of this.oldCache) {
  			if (!this.cache.has(el[0])) {
  				oldCacheSize++;
  			}
  		}

  		return this._size + oldCacheSize;
  	}
  }

  var quickLru = QuickLRU;

  const has = (array, key) => array.some(x => typeof x === 'string' ? x === key : x.test(key));
  const cache = new quickLru({maxSize: 100000});

  const camelCaseConvert = (input, options) => {
  	options = Object.assign({
  		deep: false
  	}, options);

  	const {exclude} = options;

  	return mapObj(input, (key, value) => {
  		if (!(exclude && has(exclude, key))) {
  			if (cache.has(key)) {
  				key = cache.get(key);
  			} else {
  				const ret = camelcase(key);

  				if (key.length < 100) { // Prevent abuse
  					cache.set(key, ret);
  				}

  				key = ret;
  			}
  		}

  		return [key, value];
  	}, {deep: options.deep});
  };

  var camelcaseKeys = (input, options) => {
  	if (Array.isArray(input)) {
  		return Object.keys(input).map(key => camelCaseConvert(input[key], options));
  	}

  	return camelCaseConvert(input, options);
  };

  const prefixProps$1 = (props, prefix) => {
    let newProps = {};
    Object.keys(props).forEach(prop => {
      newProps[`${prefix}-${prop}`] = props[prop];
    });

    return camelcaseKeys(newProps)
  };

  const listenOnRootMixin$1 = fmvLayout.mixins.listenOnRootMixin;
  const {sidebarProps: sidebarProps$1, drawerProps: drawerProps$1} = fmvLayout.utils;

  exports.FmAppSettingsBase = __vue_component__$1;
  exports.FmAppSettingsButton = __vue_component__$4;
  exports.FmAppSettingsCollapse = __vue_component__;
  exports.FmAppSettingsDrawer = __vue_component__$2;
  exports.Session = Session;
  exports.drawerProps = drawerProps$1;
  exports.listenOnRootMixin = listenOnRootMixin$1;
  exports.prefixProps = prefixProps$1;
  exports.sidebarProps = sidebarProps$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
